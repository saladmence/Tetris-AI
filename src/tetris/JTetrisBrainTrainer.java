package tetris;

import java.util.*;

import java.awt.Point;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

/**
 * Trains the brain with random weights
 */
public class JTetrisBrainTrainer extends JTetris {
    TetrisBrain brain;
    public static final double MUTATION_RATE = .0267676767;
    public static final double IMMIGRANT_RATE = 0.00;
    public static final double SURVIVOR_RATE = 0.05;
    public static final double PARENT_RATE = 0.3;
    public static final int TRIALS = 1;
    public static final int INITIAL_POPULATION_SIZE = 100;
    public static final int MAX_GENERATIONS = 5000;
    public static final int WEIGHT_COUNT = 9;
    public static final String POPULATION_FILENAME = "noHoldv2.txt";
    public static double BOARD_PERCENTAGE = .75;
    public static boolean usingGUI = false;

    private boolean brainEnabled = true;

    /**
     * Creates a new JTetris game and a brain that reads from a given text file.
     */
    JTetrisBrainTrainer() {
        super();
        brain = new TetrisBrain(POPULATION_FILENAME);
    }

    /**
     * For every tick in an active game, the result of the input action is recorded. 
     * For every result, the brain verifies that the current height doesn't exceed the board's absolute maximum height (which can be adjusted),
     * and if it does, the game stops. If no piece was found, then a new piece is added. 
     * @param verb, the input action
     */
    @Override
    public void tick(Board.Action verb) {
        if (!gameOn) {
            return;
        }

        Board.Result result = null;

        if (brainEnabled && board.getCurrentPiece() != null) {
            result = board.move(verb);
        }

        if(result == null) return;

        switch (result) {
          case SUCCESS:
            if (board.getMaxHeight() > HEIGHT*BOARD_PERCENTAGE) {
                stopGame();
                break;
            }
          case OUT_BOUNDS:
            break;
          case PLACE:
            if (board.getMaxHeight() > HEIGHT*BOARD_PERCENTAGE) {
                stopGame();
                break;
            }
          case NO_PIECE:
            if (gameOn) {
                addNewPiece();
            }
            if (board.getMaxHeight() > HEIGHT*BOARD_PERCENTAGE) {
                stopGame();
                break;
            }
            break;
        }

        repaint();
    }

    /**
     * If the GUI is on, then the super method is called. 
     * Otherwise, a new board with the specific width and width and a new piece is created. 
     */
    @Override
    public void startGame() {
        if(usingGUI) super.startGame();

        else{
            board = new TetrisBoard(WIDTH, HEIGHT + TOP_SPACE);
            count = 0;
            gameOn = true;
            random = new Random();
            addNewPiece();
        }
    }

    /**
     * Attempts to spawn a new piece generated by randomly picking the next piece at the middle of the spawning area.
     * If unsuccessful, the game is stopped. Otherwise, the count of pieces is incremented and updated on the GUI. 
     */
    @Override
    public void addNewPiece() {
        count++;
        Piece nextPiece = pickNextPiece();
        try {
            board.nextPiece(nextPiece, new Point(board.getWidth() / 2 - nextPiece.getWidth() / 2, HEIGHT));
        } catch(IllegalArgumentException ex) {
            stopGame();
            return;
        }

        if(usingGUI) countLabel.setText(Integer.toString(count));
    }

    /**
     * If the GUI is used, the super stopGame is called. 
     * Otherwise, the boolean tracking if the game is active or not is set to false.
     */
    @Override
    public void stopGame() {
        if(usingGUI) super.stopGame();
        else gameOn = false;
    }

    public static void main(String[] args) {
        int generation = 0;
        JTetrisBrainTrainer game = new JTetrisBrainTrainer();
        JTetrisBrainIndividual[] pop = game.brain.getPopulation();
        if(usingGUI) createGUI(game);

        // Prints out features of the training run
        System.out.println("Generation Size: " + INITIAL_POPULATION_SIZE);
        System.out.println("Max Generations: " + MAX_GENERATIONS);
        System.out.println("Trials per ind: " + TRIALS);
        System.out.println("Mutation Rate: " + MUTATION_RATE);
        System.out.println("Immigrant Rate: " + IMMIGRANT_RATE);
        System.out.println("Surivor Rate: " + SURVIVOR_RATE);
        System.out.println("Parent Rate: " + PARENT_RATE);
        System.out.println("Board Height: " + HEIGHT * BOARD_PERCENTAGE);
        System.out.println("File: " + POPULATION_FILENAME);

        // Loops through every generation 
        while (generation < MAX_GENERATIONS) {
            double averageScore = 0;
            int maxRowsCleared = 0, maxPiecesPlaced = 0;
            int minRowsCleared = Integer.MAX_VALUE, minPiecesPlaced = Integer.MAX_VALUE;

            // Loops through every individual in the population
            for (int i = 0; i < INITIAL_POPULATION_SIZE; i++) {
                double totalScore = 0.0, totalFitness = 0.0;
                if(i%(INITIAL_POPULATION_SIZE/4) == 0)System.out.println("Gen " + generation + " person " + i);

                // Each individual brain gets to play TRIALS number of times to ensure the scores are not flukes/reduce randomness
                for(int j = 0; j < TRIALS; j++){
                    game.brain.setCurrentIndividual(i);
                    game.startGame();
                    
                    // Executes the moves
                    while (game.gameOn) {
                        game.tick(game.brain.nextMove(game.board));
                    }
    
                    // Calculates the brain's final fitness and score
                    Board finalBoard = game.board; 
                    double fitness = game.brain.calcFitness(finalBoard);
                    totalFitness += fitness;
                    totalScore += game.brain.calcScore((TetrisBoard)finalBoard);

                    maxRowsCleared = Math.max(maxRowsCleared, ((TetrisBoard)finalBoard).getTotalRowsCleared());
                    maxPiecesPlaced = Math.max(maxPiecesPlaced, ((TetrisBoard)finalBoard).getScore());
    
                    minRowsCleared = Math.min(minRowsCleared, ((TetrisBoard)finalBoard).getTotalRowsCleared());
                    minPiecesPlaced = Math.min(minPiecesPlaced, ((TetrisBoard)finalBoard).getScore());
                }

                // Tracks average statistics across the population
                pop[i].setFitness(totalFitness/TRIALS);
                pop[i].setScore(totalScore/TRIALS);
                averageScore += (totalScore/TRIALS);
            }

            // Prints a summary of how the generation performed as a whole, useful for seeing if the brain is improving
            System.out.println("Generation " + generation);
            System.out.println("Max/Min Rows Cleared: " + maxRowsCleared + "/" + minRowsCleared);
            System.out.println("Max/Min Pieces Placed: " + maxPiecesPlaced + "/" + minPiecesPlaced);
            System.out.println("Average Goodness Score: " + averageScore/INITIAL_POPULATION_SIZE);
            System.out.println("--------------------------------------");

            // Sorts the brains by best to worst scores
            Arrays.sort(pop, new Comparator<JTetrisBrainIndividual>() {
                @Override
                public int compare(JTetrisBrainIndividual i1, JTetrisBrainIndividual i2) {
                    return Double.compare(i2.getScore(), i1.getScore());
                }
            });

            // Records every brain's weight values and score
            try(BufferedWriter writer = new BufferedWriter(new FileWriter(POPULATION_FILENAME))){
                writer.write(("Generation " + generation) + "\n");
                for (JTetrisBrainIndividual i : pop) {
                    double[] weights = i.getWeights();
                    for(double w : weights) writer.write(w + " ");
                    writer.write("| " + i.getScore() + "\n");
                }
            }
            catch (IOException e) {
                System.err.println("file not found or unsupported encoding :(");
                e.printStackTrace();
                return;
            }

            // Keeps the top performing brains (determined by survivor rate) into the next generation.
            // Designates a number of brains (determined by parent rate) as parents, of which two distinct brains will breed and produce new brains.
            // The child is then mutated to introduce variation. 
            int top = (int) (pop.length * PARENT_RATE);
            int nextGen = (int)(pop.length * SURVIVOR_RATE);
            Random r = new Random();
            for (int i = nextGen; i < pop.length - (int)(IMMIGRANT_RATE*INITIAL_POPULATION_SIZE); i++) {
                JTetrisBrainIndividual parent1 = pop[r.nextInt(top)];
                JTetrisBrainIndividual parent2 = pop[r.nextInt(top)];
                while(parent1.equals(parent2)) parent2 = pop[r.nextInt(top)];

                JTetrisBrainIndividual child = game.brain.crossOver(parent1, parent2);
                game.brain.mutate(child);

                pop[i] = child;
            }

            // Replaces the worst performing brains with completely random values for variation. 
            for(int i = pop.length - (int)(IMMIGRANT_RATE*INITIAL_POPULATION_SIZE); i < pop.length; i++){
                pop[i] = new JTetrisBrainIndividual();
            }

            generation++;
        }
    }
}
